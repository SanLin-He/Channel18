#pragma kernel Setup
#pragma kernel Immediate
#pragma kernel Delay
#pragma kernel Transform
#pragma kernel Clip

#define THREAD [numthreads(8, 1, 1)]
#define DISCARD_OVERFLOW if (id.x >= _ParticleCount) return;

#include "Assets/Packages/Voxelizer/Shaders/Voxel.cginc"
#include "../Common/Random.cginc"
#include "../Common/Quaternion.cginc"
#include "../Common/Noise/SimplexNoiseGrad3D.cginc"
#include "../Common/VoxelParticle.cginc"

uint _Width, _Height, _Depth;
float _UnitLength;
int _Level;

StructuredBuffer<Voxel> _VoxelBuffer;
uint _VoxelCount;

RWStructuredBuffer<VParticle> _ParticleBuffer;
uint _ParticleCount;

float2 _DT;

half2 _Speed; // min, max
half2 _Damper; // drag, speed_imit
half3 _Gravity;
half2 _Life; // dt / max_life, dt / (max_life * speed_to_life)
half2 _Spin; // max_spin * dt, speed_to_spin * dt
half2 _NoiseParams; // frequency, amplitude * dt
float3 _NoiseOffset;

uint _Threshold;

// Deterministic random rotation axis.
float3 RotationAxis(float2 uv)
{
    // Uniformaly distributed points
    // http://mathworld.wolfram.com/SpherePointPicking.html
    float u = nrand(uv, 10) * 2 - 1;
    float u2 = sqrt(1 - u * u);
    float sn, cs;
    sincos(nrand(uv, 11) * PI * 2, sn, cs);
    return float3(u2 * cs, u2 * sn, u);
}

VParticle UpdatePosition(VParticle particle, uint2 id) 
{
    float3 p = particle.position;
    float3 v = particle.velocity;

    // Apply the velocity cap.
    float lv = max(length(v.xyz), 1e-6);
    v.xyz = v * min(lv, _Damper.y) / lv;

    // Update the position with the velocity.
    p.xyz += v.xyz * _DT.x;
    particle.position = p;

    return particle;
}

VParticle UpdateVelocity(VParticle particle, uint2 id)
{
    float3 p = particle.position;
    float3 v = particle.velocity;

    // Drag and acceleration.
    v.xyz = v.xyz * _Damper.x + _Gravity.xyz;

    // Accelerate with the turbulent noise field.
    float3 seed = p.xyz;
    float3 np = (seed + _NoiseOffset) * _NoiseParams.x;
    float3 n1 = snoise_grad(np);
    float3 n2 = snoise_grad(np + float3(21.83, 13.28, 7.32));
    v.xyz += cross(n1, n2) * _NoiseParams.y * particle.speed;
    particle.velocity = v;

    return particle;
}

VParticle UpdateRotation(VParticle particle, uint2 id)
{
    float4 r = particle.rotation;
    float3 v = particle.velocity;

    // Calculate the angular velocity.
    float delta = min(_Spin.x, length(v.xyz) * _Spin.y);
    delta *= 1 - nrand(id, 18) * 0.5;

    // Convert it to a quaternion.
    float sn, cs;
    sincos(delta, sn, cs);
    float4 dq = float4(RotationAxis(id) * sn, cs);

    // Apply the quaternion and normalize it.
    particle.rotation = normalize(qmul(dq, r));

    return particle;
}

uint3 GetPosition(uint index) {
    uint3 position;
    uint wh = _Width * _Height;
    position.z = index / wh;
    int rem = index % wh;
    position.y = rem / _Width;
    position.x = rem % _Width;
    return position;
}

uint GetIndex(uint3 position, uint width, uint height, uint depth)
{
    return position.x + position.y * width + position.z * (width * height);
}

Voxel GetVoxel(uint i) {
    if (i < _VoxelCount) {
        return _VoxelBuffer[i];
    }

    Voxel v;
    v.flag = false;
    v.position = float3(0, 0, 0);
    v.uv = float2(0, 0);
    return v;
}

/*
bool DownSample(uint id, uint level, out uint index)
{
    uint3 p = GetPosition(id);
    uint w = _Width >> level;
    uint h = _Height >> level;
    uint d = _Depth >> level;
    uint x = p.x >> level;
    uint y = p.y >> level;
    uint z = p.z >> level;

    index = GetIndex(uint3(x, y, z), w, h, d);

    uint div = uint(pow(2, level));
    uint rx = p.x % div;
    uint ry = p.y % div;
    uint rz = p.z % div;
    return (rx == 0 && ry == 0 && rz == 0) && (x < w && y < h && z < d);
}
*/

THREAD
void Setup (uint3 id : SV_DispatchThreadID)
{
    DISCARD_OVERFLOW

    Voxel v = GetVoxel(id.x);

    VParticle particle;
    particle.position = v.position;
    particle.rotation = QUATERNION_IDENTITY;
    particle.scale = float3(_UnitLength, _UnitLength, _UnitLength);
    particle.velocity = float3(0, 0, 0);
    particle.speed = lerp(_Speed.x, _Speed.y, nrand(id.xy));
    _ParticleBuffer[id.x] = particle;
}

THREAD
void Immediate (uint3 id : SV_DispatchThreadID)
{
    DISCARD_OVERFLOW

    Voxel v = GetVoxel(id.x);
    VParticle particle = _ParticleBuffer[id.x];

    particle.position = v.position;
    particle.velocity = float3(0, 0, 0);
    particle.scale = float3(1, 1, 1) * lerp(0, _UnitLength, (float)v.flag);
    particle.rotation = QUATERNION_IDENTITY;
    _ParticleBuffer[id.x] = particle;
}

half _DelaySpeed, _TransformSpeed, _ClipSpeed;

THREAD
void Delay (uint3 id : SV_DispatchThreadID)
{
    DISCARD_OVERFLOW

    Voxel v = GetVoxel(id.x);
    VParticle particle = _ParticleBuffer[id.x];

    float dt = saturate(_DT.x * particle.speed * _DelaySpeed);
    particle.position = v.position;
    particle.velocity = lerp(particle.velocity, float3(0, 0, 0), dt);
    particle.scale = lerp(particle.scale, float3(_UnitLength, _UnitLength, _UnitLength) * (float)v.flag, dt);
    particle.rotation = q_slerp(particle.rotation, QUATERNION_IDENTITY, dt);
    _ParticleBuffer[id.x] = particle;
}

THREAD
void Transform (uint3 id : SV_DispatchThreadID)
{
    DISCARD_OVERFLOW

    Voxel v = GetVoxel(id.x);
    VParticle particle = _ParticleBuffer[id.x];

    float dt = saturate(_DT.x * particle.speed * _TransformSpeed);
    particle.position = lerp(particle.position, v.position, dt);
    particle.velocity = lerp(particle.velocity, float3(0, 0, 0), dt);
    particle.scale = lerp(particle.scale, float3(_UnitLength, _UnitLength, _UnitLength) * (float)v.flag, dt);
    particle.rotation = q_slerp(particle.rotation, QUATERNION_IDENTITY, dt);
    _ParticleBuffer[id.x] = particle;
}

float3 _ClipMin, _ClipMax;

THREAD
void Clip (uint3 id : SV_DispatchThreadID)
{
    DISCARD_OVERFLOW


    Voxel v = GetVoxel(id.x);
    VParticle particle = _ParticleBuffer[id.x];
    
    float dt = saturate(_DT.x * particle.speed * _ClipSpeed);

    float min = step(_ClipMin.x, v.position.x) * step(_ClipMin.y, v.position.y) * step(_ClipMin.z, v.position.z);
    float max = step(v.position.x, _ClipMax.x) * step(v.position.y, _ClipMax.y) * step(v.position.z, _ClipMax.z);
    float flag = (float) v.flag * min * max;

    particle.position = v.position;
    particle.velocity = float3(0, 0, 0);
    particle.scale = lerp(particle.scale, float3(_UnitLength, _UnitLength, _UnitLength) * flag, dt);
    particle.rotation = QUATERNION_IDENTITY;
    _ParticleBuffer[id.x] = particle;
}

